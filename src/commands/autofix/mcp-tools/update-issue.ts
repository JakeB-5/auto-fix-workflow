/**
 * @module commands/autofix/mcp-tools/update-issue
 * @description Issue update MCP tool
 */

import { z } from 'zod';
import type { Result } from '../../../common/types/result.js';
import { ok, err } from '../../../common/types/result.js';

/**
 * Schema for update issue parameters
 */
export const UpdateIssueInputSchema = z.object({
  issueNumber: z.number(),
  state: z.enum(['open', 'closed']).optional(),
  labels: z.array(z.string()).optional(),
  addLabels: z.array(z.string()).optional(),
  removeLabels: z.array(z.string()).optional(),
  comment: z.string().optional(),
  assignees: z.array(z.string()).optional(),
});

export type UpdateIssueInput = z.infer<typeof UpdateIssueInputSchema>;

/**
 * Update issue result
 */
export interface UpdateIssueResult {
  readonly issueNumber: number;
  readonly updated: boolean;
  readonly commentId?: number | undefined;
}

/**
 * Update issue error
 */
export interface UpdateIssueError {
  readonly code: UpdateIssueErrorCode;
  readonly message: string;
  readonly cause?: Error;
}

export type UpdateIssueErrorCode =
  | 'AUTH_FAILED'
  | 'NOT_FOUND'
  | 'VALIDATION_FAILED'
  | 'API_ERROR'
  | 'UNKNOWN';

/**
 * GitHub configuration for issue updates
 */
export interface UpdateIssueConfig {
  readonly token: string;
  readonly owner: string;
  readonly repo: string;
  readonly apiBaseUrl?: string | undefined;
}

/**
 * Update Issue MCP Tool
 *
 * Updates GitHub issues (state, labels, comments)
 */
export class UpdateIssueTool {
  private readonly config: UpdateIssueConfig;

  constructor(config: UpdateIssueConfig) {
    this.config = config;
  }

  /**
   * Tool name for MCP registration
   */
  static readonly toolName = 'update_issue';

  /**
   * Tool description
   */
  static readonly toolDescription = 'Update GitHub issue state, labels, and add comments';

  /**
   * Update an issue
   */
  async updateIssue(
    params: UpdateIssueInput
  ): Promise<Result<UpdateIssueResult, UpdateIssueError>> {
    try {
      let updated = false;
      let commentId: number | undefined;

      // Update issue if state or labels changed
      if (params.state !== undefined || params.labels !== undefined || params.assignees !== undefined) {
        const patchData: {
          state?: 'open' | 'closed';
          labels?: readonly string[];
          assignees?: readonly string[];
        } = {};
        if (params.state !== undefined) patchData.state = params.state;
        if (params.labels !== undefined) patchData.labels = params.labels;
        if (params.assignees !== undefined) patchData.assignees = params.assignees;
        await this.patchIssue(params.issueNumber, patchData);
        updated = true;
      }

      // Handle addLabels
      if (params.addLabels && params.addLabels.length > 0) {
        await this.addLabels(params.issueNumber, params.addLabels);
        updated = true;
      }

      // Handle removeLabels
      if (params.removeLabels && params.removeLabels.length > 0) {
        await this.removeLabels(params.issueNumber, params.removeLabels);
        updated = true;
      }

      // Add comment if provided
      if (params.comment) {
        commentId = await this.addComment(params.issueNumber, params.comment);
        updated = true;
      }

      const result: UpdateIssueResult = {
        issueNumber: params.issueNumber,
        updated,
      };
      if (commentId !== undefined) {
        (result as { commentId?: number }).commentId = commentId;
      }
      return ok(result);
    } catch (error) {
      return err(this.mapError(error));
    }
  }

  /**
   * Add a comment linking to a PR
   */
  async addPRLinkComment(
    issueNumber: number,
    prNumber: number,
    prUrl: string
  ): Promise<Result<UpdateIssueResult, UpdateIssueError>> {
    const comment = `## Auto-Fix PR Created

A pull request has been automatically created to address this issue:

- PR: #${prNumber}
- Link: ${prUrl}

*This comment was auto-generated by auto-fix-workflow*`;

    return this.updateIssue({
      issueNumber,
      comment,
    });
  }

  /**
   * Mark issue as in-progress
   */
  async markInProgress(
    issueNumber: number
  ): Promise<Result<UpdateIssueResult, UpdateIssueError>> {
    return this.updateIssue({
      issueNumber,
      addLabels: ['in-progress'],
      removeLabels: ['auto-fix'],
      comment: 'Auto-fix processing has started for this issue.',
    });
  }

  /**
   * Mark issue as fixed (but not closed - PR will close it)
   */
  async markFixed(
    issueNumber: number,
    prNumber: number,
    prUrl: string
  ): Promise<Result<UpdateIssueResult, UpdateIssueError>> {
    return this.updateIssue({
      issueNumber,
      addLabels: ['auto-fixed'],
      removeLabels: ['in-progress', 'auto-fix'],
      comment: `This issue has been addressed in PR #${prNumber}: ${prUrl}

The issue will be automatically closed when the PR is merged.

*Auto-generated by auto-fix-workflow*`,
    });
  }

  /**
   * Mark issue as failed
   */
  async markFailed(
    issueNumber: number,
    reason: string
  ): Promise<Result<UpdateIssueResult, UpdateIssueError>> {
    return this.updateIssue({
      issueNumber,
      addLabels: ['auto-fix-failed'],
      removeLabels: ['in-progress'],
      comment: `## Auto-Fix Failed

The automatic fix attempt failed:

\`\`\`
${reason}
\`\`\`

This issue requires manual attention.

*Auto-generated by auto-fix-workflow*`,
    });
  }

  /**
   * Patch issue via API
   */
  private async patchIssue(
    issueNumber: number,
    updates: {
      state?: 'open' | 'closed';
      labels?: readonly string[];
      assignees?: readonly string[];
    }
  ): Promise<void> {
    const baseUrl = this.config.apiBaseUrl ?? 'https://api.github.com';
    const url = `${baseUrl}/repos/${this.config.owner}/${this.config.repo}/issues/${issueNumber}`;

    const response = await fetch(url, {
      method: 'PATCH',
      headers: {
        Authorization: `Bearer ${this.config.token}`,
        Accept: 'application/vnd.github+json',
        'X-GitHub-Api-Version': '2022-11-28',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(updates),
    });

    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
    }
  }

  /**
   * Add labels to issue
   */
  private async addLabels(
    issueNumber: number,
    labels: readonly string[]
  ): Promise<void> {
    const baseUrl = this.config.apiBaseUrl ?? 'https://api.github.com';
    const url = `${baseUrl}/repos/${this.config.owner}/${this.config.repo}/issues/${issueNumber}/labels`;

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${this.config.token}`,
        Accept: 'application/vnd.github+json',
        'X-GitHub-Api-Version': '2022-11-28',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ labels }),
    });

    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
    }
  }

  /**
   * Remove labels from issue
   */
  private async removeLabels(
    issueNumber: number,
    labels: readonly string[]
  ): Promise<void> {
    const baseUrl = this.config.apiBaseUrl ?? 'https://api.github.com';

    for (const label of labels) {
      const url = `${baseUrl}/repos/${this.config.owner}/${this.config.repo}/issues/${issueNumber}/labels/${encodeURIComponent(label)}`;

      const response = await fetch(url, {
        method: 'DELETE',
        headers: {
          Authorization: `Bearer ${this.config.token}`,
          Accept: 'application/vnd.github+json',
          'X-GitHub-Api-Version': '2022-11-28',
        },
      });

      // 404 is ok - label might not exist
      if (!response.ok && response.status !== 404) {
        throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
      }
    }
  }

  /**
   * Add comment to issue
   */
  private async addComment(
    issueNumber: number,
    body: string
  ): Promise<number> {
    const baseUrl = this.config.apiBaseUrl ?? 'https://api.github.com';
    const url = `${baseUrl}/repos/${this.config.owner}/${this.config.repo}/issues/${issueNumber}/comments`;

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${this.config.token}`,
        Accept: 'application/vnd.github+json',
        'X-GitHub-Api-Version': '2022-11-28',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ body }),
    });

    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json() as { id: number };
    return data.id;
  }

  /**
   * Map error to UpdateIssueError
   */
  private mapError(error: unknown): UpdateIssueError {
    if (error instanceof Error) {
      const message = error.message.toLowerCase();

      if (message.includes('401') || message.includes('unauthorized')) {
        return { code: 'AUTH_FAILED', message: 'GitHub authentication failed', cause: error };
      }
      if (message.includes('404')) {
        return { code: 'NOT_FOUND', message: 'Issue not found', cause: error };
      }
      if (message.includes('422')) {
        return { code: 'VALIDATION_FAILED', message: error.message, cause: error };
      }

      return { code: 'API_ERROR', message: error.message, cause: error };
    }

    return { code: 'UNKNOWN', message: String(error) };
  }
}

/**
 * Create tool definition for MCP server
 */
export function createUpdateIssueTool(config: UpdateIssueConfig) {
  const tool = new UpdateIssueTool(config);

  return {
    name: UpdateIssueTool.toolName,
    description: UpdateIssueTool.toolDescription,
    inputSchema: {
      type: 'object' as const,
      properties: {
        issueNumber: {
          type: 'number',
          description: 'Issue number to update',
        },
        state: {
          type: 'string',
          enum: ['open', 'closed'],
          description: 'New issue state',
        },
        labels: {
          type: 'array',
          items: { type: 'string' },
          description: 'Replace all labels',
        },
        addLabels: {
          type: 'array',
          items: { type: 'string' },
          description: 'Labels to add',
        },
        removeLabels: {
          type: 'array',
          items: { type: 'string' },
          description: 'Labels to remove',
        },
        comment: {
          type: 'string',
          description: 'Comment to add',
        },
        assignees: {
          type: 'array',
          items: { type: 'string' },
          description: 'Assignees to set',
        },
      },
      required: ['issueNumber'],
    },
    handler: async (params: UpdateIssueInput) => {
      return tool.updateIssue(params);
    },
  };
}
