/**
 * @module commands/triage/dry-run
 * @description Dry-run mode simulation for triage operations
 */

import type { AsanaTask, TaskAnalysis, TriageResult, CreatedIssueInfo } from './types.js';

/**
 * Simulated action types
 */
export type SimulatedActionType =
  | 'ANALYZE_TASK'
  | 'CREATE_GITHUB_ISSUE'
  | 'UPDATE_ASANA_TASK'
  | 'ADD_TAG'
  | 'MOVE_SECTION'
  | 'ADD_COMMENT';

/**
 * Simulated action
 */
export interface SimulatedAction {
  readonly type: SimulatedActionType;
  readonly taskGid: string;
  readonly taskName: string;
  readonly description: string;
  readonly details: Record<string, unknown>;
}

/**
 * Dry-run simulation result
 */
export interface DryRunResult {
  readonly actions: readonly SimulatedAction[];
  readonly summary: DryRunSummary;
}

/**
 * Dry-run summary
 */
export interface DryRunSummary {
  readonly totalTasks: number;
  readonly issuesWouldCreate: number;
  readonly asanaUpdates: number;
  readonly tagsWouldAdd: number;
  readonly sectionsWouldMove: number;
}

/**
 * Dry-run simulator
 */
export class DryRunSimulator {
  private readonly actions: SimulatedAction[] = [];

  /**
   * Simulate task analysis
   */
  simulateAnalysis(task: AsanaTask): TaskAnalysis {
    this.actions.push({
      type: 'ANALYZE_TASK',
      taskGid: task.gid,
      taskName: task.name,
      description: `Analyze task with AI to determine type, priority, and labels`,
      details: {
        taskNotes: task.notes?.slice(0, 100),
        hasDueDate: !!task.dueOn,
        hasAssignee: !!task.assignee,
      },
    });

    // Return a mock analysis
    return {
      issueType: 'feature',
      priority: 'medium',
      labels: ['auto-fix', 'triage-reviewed'],
      component: 'general',
      relatedFiles: [],
      summary: task.notes || task.name,
      acceptanceCriteria: ['Criteria would be generated by AI'],
      confidence: 0.8,
    };
  }

  /**
   * Simulate GitHub issue creation
   */
  simulateCreateIssue(task: AsanaTask, analysis: TaskAnalysis): CreatedIssueInfo {
    const mockIssueNumber = Math.floor(Math.random() * 1000) + 1;

    this.actions.push({
      type: 'CREATE_GITHUB_ISSUE',
      taskGid: task.gid,
      taskName: task.name,
      description: `Create GitHub issue with title "${task.name}"`,
      details: {
        title: task.name,
        labels: analysis.labels,
        type: analysis.issueType,
        priority: analysis.priority,
      },
    });

    return {
      asanaTaskGid: task.gid,
      githubIssueNumber: mockIssueNumber,
      githubIssueUrl: `https://github.com/owner/repo/issues/${mockIssueNumber}`,
      title: task.name,
    };
  }

  /**
   * Simulate Asana task update
   */
  simulateUpdateTask(
    task: AsanaTask,
    updates: {
      sectionGid?: string;
      tagGids?: string[];
      comment?: string;
      customFields?: Record<string, string | number>;
    }
  ): void {
    if (updates.sectionGid) {
      this.actions.push({
        type: 'MOVE_SECTION',
        taskGid: task.gid,
        taskName: task.name,
        description: `Move task to section ${updates.sectionGid}`,
        details: { sectionGid: updates.sectionGid },
      });
    }

    if (updates.tagGids && updates.tagGids.length > 0) {
      for (const tagGid of updates.tagGids) {
        this.actions.push({
          type: 'ADD_TAG',
          taskGid: task.gid,
          taskName: task.name,
          description: `Add tag ${tagGid} to task`,
          details: { tagGid },
        });
      }
    }

    if (updates.comment) {
      this.actions.push({
        type: 'ADD_COMMENT',
        taskGid: task.gid,
        taskName: task.name,
        description: `Add comment to task`,
        details: { commentPreview: updates.comment.slice(0, 100) },
      });
    }

    if (updates.customFields) {
      this.actions.push({
        type: 'UPDATE_ASANA_TASK',
        taskGid: task.gid,
        taskName: task.name,
        description: `Update custom fields`,
        details: { customFields: updates.customFields },
      });
    }
  }

  /**
   * Get all simulated actions
   */
  getActions(): readonly SimulatedAction[] {
    return this.actions;
  }

  /**
   * Get simulation result
   */
  getResult(): DryRunResult {
    const summary: DryRunSummary = {
      totalTasks: new Set(this.actions.map((a) => a.taskGid)).size,
      issuesWouldCreate: this.actions.filter((a) => a.type === 'CREATE_GITHUB_ISSUE').length,
      asanaUpdates: this.actions.filter((a) => a.type === 'UPDATE_ASANA_TASK').length,
      tagsWouldAdd: this.actions.filter((a) => a.type === 'ADD_TAG').length,
      sectionsWouldMove: this.actions.filter((a) => a.type === 'MOVE_SECTION').length,
    };

    return { actions: this.actions, summary };
  }

  /**
   * Clear all actions
   */
  clear(): void {
    this.actions.length = 0;
  }
}

/**
 * Simulate actions for a list of tasks
 */
export function simulateActions(tasks: readonly AsanaTask[]): DryRunResult {
  const simulator = new DryRunSimulator();

  for (const task of tasks) {
    // Simulate analysis
    const analysis = simulator.simulateAnalysis(task);

    // Simulate issue creation
    const issueInfo = simulator.simulateCreateIssue(task, analysis);

    // Simulate Asana updates
    simulator.simulateUpdateTask(task, {
      sectionGid: 'mock-processed-section',
      tagGids: ['mock-synced-tag'],
      comment: `GitHub issue created: ${issueInfo.githubIssueUrl}`,
      customFields: {
        'github-issue': issueInfo.githubIssueNumber,
      },
    });
  }

  return simulator.getResult();
}

/**
 * Format dry-run result for display
 */
export function formatDryRunResult(result: DryRunResult): string {
  const lines: string[] = [
    '',
    '=== DRY RUN SIMULATION ===',
    '',
    'The following actions WOULD be performed:',
    '',
  ];

  // Group actions by task
  const actionsByTask = new Map<string, SimulatedAction[]>();
  for (const action of result.actions) {
    const existing = actionsByTask.get(action.taskGid) ?? [];
    existing.push(action);
    actionsByTask.set(action.taskGid, existing);
  }

  const entries = Array.from(actionsByTask.entries());
  for (const [taskGid, actions] of entries) {
    const taskName = actions[0]?.taskName ?? 'Unknown';
    lines.push(`Task: ${taskName} (${taskGid})`);

    for (const action of actions) {
      const icon = getActionIcon(action.type);
      lines.push(`  ${icon} ${action.description}`);
    }

    lines.push('');
  }

  lines.push('--- Summary ---');
  lines.push(`Tasks to process: ${result.summary.totalTasks}`);
  lines.push(`GitHub issues to create: ${result.summary.issuesWouldCreate}`);
  lines.push(`Asana updates: ${result.summary.asanaUpdates}`);
  lines.push(`Tags to add: ${result.summary.tagsWouldAdd}`);
  lines.push(`Section moves: ${result.summary.sectionsWouldMove}`);
  lines.push('');
  lines.push('NOTE: No changes were made (dry-run mode)');

  return lines.join('\n');
}

/**
 * Get icon for action type
 */
function getActionIcon(type: SimulatedActionType): string {
  switch (type) {
    case 'ANALYZE_TASK':
      return '[ANALYZE]';
    case 'CREATE_GITHUB_ISSUE':
      return '[CREATE]';
    case 'UPDATE_ASANA_TASK':
      return '[UPDATE]';
    case 'ADD_TAG':
      return '[TAG]';
    case 'MOVE_SECTION':
      return '[MOVE]';
    case 'ADD_COMMENT':
      return '[COMMENT]';
    default:
      return '[?]';
  }
}

/**
 * Convert dry-run result to TriageResult
 */
export function toTriageResult(dryRunResult: DryRunResult): TriageResult {
  return {
    processed: dryRunResult.summary.totalTasks,
    created: dryRunResult.summary.issuesWouldCreate,
    skipped: 0,
    failed: 0,
    durationMs: 0,
  };
}
