/**
 * @module workflow/code-fix-strategy/pr-creator
 * @description Pull request creation logic
 */

import type {
  IssueGroup,
  PullRequest,
  CreatePRParams,
} from '../../common/types/index.js';
import type { FileChange } from './types.js';

/**
 * Create PR parameters from issue group and changes
 *
 * @param group - Issue group
 * @param changes - File changes
 * @returns PR creation parameters
 */
export function createPRParams(
  group: IssueGroup,
  changes: readonly FileChange[]
): CreatePRParams {
  const title = generatePRTitle(group);
  const body = generatePRBody(group, changes);
  const linkedIssues = group.issues.map((issue) => issue.number);
  const labels = extractLabels(group);

  return {
    title,
    body,
    headBranch: group.branchName,
    baseBranch: 'main',
    linkedIssues,
    labels,
    draft: false,
  };
}

/**
 * Generate PR title
 *
 * @param group - Issue group
 * @returns PR title
 */
function generatePRTitle(group: IssueGroup): string {
  const type = determinePRType(group);
  const description = generatePRDescription(group);

  return `${type}: ${description}`;
}

/**
 * Determine PR type based on issues
 *
 * @param group - Issue group
 * @returns PR type
 */
function determinePRType(group: IssueGroup): string {
  const types = group.issues.map((issue) => issue.type);
  const uniqueTypes = Array.from(new Set(types));

  if (uniqueTypes.length === 1) {
    const type = uniqueTypes[0] ?? 'fix';
    return type === 'bug' ? 'fix' : type;
  }

  // Mixed types - use most common
  const typeCounts = new Map<string, number>();
  for (const type of types) {
    typeCounts.set(type, (typeCounts.get(type) || 0) + 1);
  }

  let maxType = 'fix';
  let maxCount = 0;

  for (const [type, count] of typeCounts) {
    if (count > maxCount) {
      maxCount = count;
      maxType = type === 'bug' ? 'fix' : type;
    }
  }

  return maxType;
}

/**
 * Generate PR description
 *
 * @param group - Issue group
 * @returns Description string
 */
function generatePRDescription(group: IssueGroup): string {
  if (group.issues.length === 1) {
    return group.issues[0]?.title ?? 'Fix issue';
  }

  // Multiple issues - use group name
  return `${group.name} (${group.issues.length} issues)`;
}

/**
 * Generate PR body
 *
 * @param group - Issue group
 * @param changes - File changes
 * @returns PR body markdown
 */
function generatePRBody(
  group: IssueGroup,
  changes: readonly FileChange[]
): string {
  const sections: string[] = [];

  // Summary section
  sections.push('## Summary');
  sections.push(generateSummary(group));
  sections.push('');

  // Issues section
  sections.push('## Issues Fixed');
  sections.push(generateIssuesList(group));
  sections.push('');

  // Changes section
  sections.push('## Changes');
  sections.push(generateChangesSummary(changes));
  sections.push('');

  // Checklist section
  sections.push('## Verification Checklist');
  sections.push('- [x] Tests pass');
  sections.push('- [x] Type checks pass');
  sections.push('- [x] Linting passes');
  sections.push('- [x] No forbidden patterns detected');
  sections.push('');

  // Footer
  sections.push('---');
  sections.push('*Auto-generated by auto-fix-workflow*');

  return sections.join('\n');
}

/**
 * Generate summary text
 *
 * @param group - Issue group
 * @returns Summary markdown
 */
function generateSummary(group: IssueGroup): string {
  const lines: string[] = [];

  lines.push(
    `This PR addresses ${group.issues.length} issue(s) in the **${group.name}** group.`
  );
  lines.push('');

  // Add component information
  if (group.components.length > 0) {
    lines.push(`**Affected components:** ${group.components.join(', ')}`);
  }

  // Add priority
  lines.push(`**Priority:** ${group.priority}`);

  return lines.join('\n');
}

/**
 * Generate issues list
 *
 * @param group - Issue group
 * @returns Issues list markdown
 */
function generateIssuesList(group: IssueGroup): string {
  const lines: string[] = [];

  for (const issue of group.issues) {
    lines.push(`- Fixes #${issue.number}: ${issue.title}`);

    // Add acceptance criteria if present
    if (issue.acceptanceCriteria.length > 0) {
      for (const criteria of issue.acceptanceCriteria) {
        const status = criteria.completed ? 'x' : ' ';
        lines.push(`  - [${status}] ${criteria.description}`);
      }
    }
  }

  return lines.join('\n');
}

/**
 * Generate changes summary
 *
 * @param changes - File changes
 * @returns Changes summary markdown
 */
function generateChangesSummary(
  changes: readonly FileChange[]
): string {
  const lines: string[] = [];

  // Summary statistics
  const added = changes.filter((c) => c.type === 'added').length;
  const modified = changes.filter((c) => c.type === 'modified').length;
  const deleted = changes.filter((c) => c.type === 'deleted').length;

  const totalAdditions = changes.reduce(
    (sum, c) => sum + c.additions,
    0
  );
  const totalDeletions = changes.reduce(
    (sum, c) => sum + c.deletions,
    0
  );

  lines.push(
    `**${changes.length} file(s) changed:** ` +
    `${added} added, ${modified} modified, ${deleted} deleted`
  );
  lines.push(
    `**Lines:** +${totalAdditions} -${totalDeletions}`
  );
  lines.push('');

  // List changed files
  lines.push('### Changed Files');
  for (const change of changes) {
    const icon = getChangeIcon(change.type);
    lines.push(
      `- ${icon} \`${change.path}\` (+${change.additions} -${change.deletions})`
    );
  }

  return lines.join('\n');
}

/**
 * Get icon for change type
 *
 * @param type - Change type
 * @returns Icon character
 */
function getChangeIcon(type: 'added' | 'modified' | 'deleted'): string {
  switch (type) {
    case 'added':
      return '‚ú®';
    case 'modified':
      return 'üìù';
    case 'deleted':
      return 'üóëÔ∏è';
  }
}

/**
 * Extract labels from issue group
 *
 * @param group - Issue group
 * @returns Array of unique labels
 */
function extractLabels(group: IssueGroup): readonly string[] {
  const labels = new Set<string>();

  // Add automated fix label
  labels.add('automated-fix');

  // Add priority label
  labels.add(`priority:${group.priority}`);

  // Add issue labels
  for (const issue of group.issues) {
    for (const label of issue.labels) {
      labels.add(label);
    }
  }

  return Array.from(labels);
}

/**
 * Format PR for display
 *
 * @param pr - Pull request
 * @returns Formatted string
 */
export function formatPR(pr: PullRequest): string {
  const lines: string[] = [];

  lines.push(`PR #${pr.number}: ${pr.title}`);
  lines.push(`Status: ${pr.state}`);
  lines.push(`Branch: ${pr.headBranch} -> ${pr.baseBranch}`);
  lines.push(`URL: ${pr.url}`);
  lines.push('');
  lines.push(
    `Changes: ${pr.changedFiles} files (+${pr.additions} -${pr.deletions})`
  );

  if (pr.linkedIssues.length > 0) {
    lines.push(`Linked Issues: ${pr.linkedIssues.join(', ')}`);
  }

  return lines.join('\n');
}
